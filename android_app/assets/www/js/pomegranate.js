// Generated by CoffeeScript 1.6.2
var P, U, _db;

U = {
  log: function(message, details) {
    return U.output(message, details, "log-info");
  },
  error: function(message, details) {
    return U.output(message, details, "log-error");
  },
  output: function(message, details, cssClass) {
    var random, time;

    time = moment().format("D-MMM h:mm:ss");
    random = Math.random().toString(36).substr(2);
    console.log(message);
    if (details != null) {
      details = "<div class='log-details'>" + details + "</div>";
    }
    return $("#log").append("<div class='" + cssClass + "'>" + time + " " + message + "<span id='log-status-" + random + "'></span>" + (details || "") + "<div>");
  },
  exec: function(options) {
    return cordova.exec(options.success, options.error, options.plugin.name, options.plugin["function"], options.plugin.args);
  },
  status: function(id, status, name) {
    var $status;

    $status = $("#status-" + id);
    if ($status.length !== 0) {
      $("#status-" + id).html(status);
      return;
    }
    if (name == null) {
      name = id;
    }
    return $("#status").html("<div><b>" + name + "</b>: <span id='status-" + status + "'>" + status + "</span></div>");
  }
};

_db = {
  replicateBothWays: function() {
    var replications;

    if (P.config.local_database_name && P.config.remote_url) {
      U.log("Replicating from " + P.config.local_database_name + " to " + P.config.remote_url + " and vice versa");
      replications = {
        to: PouchDB.replicate(P.config.local_database_name, P.config.remote_url, {
          continuous: true,
          complete: function(response) {
            return U.log(JSON.stringify(response));
          }
        }),
        from: PouchDB.replicate(P.config.remote_url, P.config.local_database_name, {
          continuous: true,
          complete: function(response) {
            return U.log(JSON.stringify(response));
          }
        })
      };
      return U.log(JSON.stringify(replications));
    } else {
      U.log("Waiting for configuration to load or be entered, waiting 5 seconds");
      return _.delay(replicateBothWays, 5000);
    }
  },
  saveResults: function(results) {
    if (results.msgs.length !== 0) {
      return _(results.msgs).each(function(msg) {
        var newDoc;

        newDoc = msg;
        newDoc._id = "" + msg.time_received + "+" + msg.from;
        return P.db.put(msg, function(error, response) {
          if (error && error.status !== 409) {
            U.error("Error while saving", JSON.stringify(error));
          }
          if ((response != null) && !response.error) {
            return U.log("New message saved", msg.message);
          }
        });
      });
    }
  },
  saveAllSms: function() {
    return U.exec({
      success: _db.saveResults,
      error: function(error) {
        return U.error("Error while saving", JSON.stringify(error));
      },
      plugin: {
        name: "ReadSms",
        "function": "GetTexts",
        args: ["", -1]
      }
    });
  },
  saveAllSmsAfter: function(cutoff) {
    return U.exec({
      success: _db.saveResults,
      error: function(error) {
        return U.error("Error while saving", JSON.stringify(error));
      },
      plugin: {
        name: "ReadSms",
        "function": "GetTextsAfter",
        args: ["", cutoff, -1]
      }
    });
  }
};

P = {};

P.views = {
  msgsSent: function(doc) {
    if (doc.to && doc.processed) {
      return emit(doc._id, null);
    }
  },
  msgsRecieved: function(doc) {
    if (doc.time_received && doc.processed) {
      return emit(doc._id, null);
    }
  },
  msgsUnprocessed: function(doc) {
    var isMessage, isUnprocessed;

    isUnprocessed = !doc.processed;
    isMessage = doc.message;
    if (isMessage && isUnprocessed) {
      return emit(doc._id, null);
    }
  },
  msgsByTimeReceived: function(doc) {
    if (doc.time_received) {
      return emit(doc.time_received, null);
    }
  },
  msgsToSend: function(doc) {
    var isMessage, needsToGo;

    needsToGo = doc.to && !doc.processed;
    isMessage = doc.message;
    if (isMessage && needsToGo) {
      return emit(doc._id, null);
    }
  }
};

P.filters = {
  messageNeedsToGo: function(doc) {
    var isMessage, needsToGo;

    needsToGo = doc.to && !doc.processed;
    isMessage = doc.message;
    return isMessage && needsToGo;
  },
  msgsUnprocessed: function(doc) {
    var isUnprocessed, wasReceived;

    wasReceived = doc.time_received;
    isUnprocessed = !doc.processed;
    return wasReceived && isUnprocessed;
  }
};

P.config = {
  local_database_name: "pomegranate",
  remote_couch: "http://pomegranate.tangerinecentral.org",
  sync_previous_days: 10
};

P.boot = function() {
  var e;

  console.log("Starting service");
  cordova.define('cordova/plugin/myService', function(require, exports, module) {
    return CreateBackgroundService('org.rti.pomegranate.MyService', require, exports, module);
  });
  (cordova.require('cordova/plugin/myService')).startService(function(r) {
    return console.log("Started " + (JSON.stringify(r)), function(r) {
      return console.log("Failed to start " + (JSON.stringify(r)));
    });
  });
  console.log("Service started");
  P.sender = cordova.require('cordova/plugin/smssendingplugin');
  P.sender.isSupported(function(supported) {
    if (!supported) {
      return alert("Error\n\nThis device does not support SMS.");
    }
  }, function() {
    return console.log("Error while checking for SMS support");
  });
  U.log("Starting DB");
  try {
    P.db = new PouchDB(P.config.local_database_name, {
      adapter: "websql"
    });
    U.log("Using WebSQL adapter");
  } catch (_error) {
    e = _error;
    U.error("WebSQL database failed", e);
    try {
      P.db = new PouchDB(P.config.local_database_name, {
        adapter: "idb"
      });
      U.log("Using IDB adapter");
    } catch (_error) {
      e = _error;
      U.error("IDB database failed", e);
      try {
        P.db = new PouchDB(P.config.local_database_name, {
          adapter: "leveldb"
        });
      } catch (_error) {
        e = _error;
        U.error("LevelDB database failed", e);
      }
    }
  }
  $.extend(P.db, _db);
  console.log("Trying to load config from database");
  return P.db.get('config', function(error, doc) {
    if (doc != null) {
      console.log("Found a config: " + (JSON.stringify(doc)));
      P.config = doc;
    } else {
      bootbox.prompt("Enter the project name at " + P.config.remote_couch, function(projectName) {
        P.config = _.extend(P.config, {
          _id: "config",
          remote_url: "" + P.config.remote_couch + "/" + projectName
        });
        return P.db.put(P.config, function() {
          return location.reload();
        });
      });
    }
    return $(function() {
      var resize;

      resize = function() {
        return $("#log").height(($(window).height() - ($("#log").position().top + ($(window).height() * 0.2))) + "px");
      };
      touchScroll('log');
      $(window).on("resize", resize);
      resize();
      U.log("Starting application");
      return P.startApp();
    });
  });
};

P.startApp = function() {
  var checkMsgs;

  checkMsgs = function(callback) {
    P.db.query({
      map: P.views.msgsSent
    }, {
      reduce: false
    }, function(error, response) {
      return U.status("sent", response.rows.length);
    });
    P.db.query({
      map: P.views.msgsRecieved
    }, {
      reduce: false
    }, function(error, response) {
      return U.status("received", response.rows.length);
    });
    P.db.query({
      map: P.views.msgsUnprocessed
    }, {
      reduce: false
    }, function(error, response) {
      return U.status("processing", response.rows.length);
    });
    P.db.query({
      map: P.views.msgsByTimeReceived
    }, {
      reduce: false
    }, function(error, response) {
      return U.status("db", response.rows.length);
    });
    return P.db.query({
      map: P.views.msgsByTimeReceived
    }, {
      reduce: false,
      include_docs: true,
      limit: 1,
      descending: true
    }, function(error, response) {
      var cutoffTime, time, _ref, _ref1;

      if (error != null) {
        U.error("Error querying database", JSON.stringify(error));
      }
      if (response.rows.length === 0 || (((_ref = response.rows[0]) != null ? (_ref1 = _ref.doc) != null ? _ref1.time_received : void 0 : void 0) == null)) {
        cutoffTime = moment().subtract('days', P.config.sync_previous_days);
        return P.db.saveAllSmsAfter(cutoffTime.valueOf());
      } else {
        time = moment(parseInt(response.rows[0].doc.time_received)).format("d-MMM hh:mm");
        return P.db.saveAllSmsAfter(response.rows[0].doc.time_received);
      }
    });
  };
  window.checkAgainInterval = setInterval(checkMsgs, 10 * 1000);
  checkMsgs();
  P.db.changes({
    continuous: true,
    include_docs: true,
    filter: P.filters.messageNeedsToGo,
    onChange: function(change) {
      var doc;

      doc = change.doc;
      doc.time_sent = (new Date()).getTime();
      U.log("Message to send", JSON.stringify(_(doc).without));
      return P.sender.send({
        to: doc.to,
        message: doc.message,
        success: function() {
          U.log("Message sent", JSON.stringify(doc));
          doc.processed = true;
          return P.db.put(doc);
        },
        error: function(error) {
          return U.error("Error sending message: " + (JSON.stringify(error)), JSON.stringify(doc));
        }
      });
    }
  });
  P.db.changes({
    continuous: true,
    include_docs: true,
    filter: P.filters.msgsUnprocessed,
    onChange: function(change) {
      U.log("Message processed", JSON.stringify(change.doc));
      change.doc.processed = true;
      return P.db.put(change.doc);
    }
  });
  P.db.replicateBothWays();
  document.addEventListener("online", (function() {
    U.log('Phone online');
    return P.db.replicateBothWays();
  }), false);
  return document.addEventListener("offline", (function() {
    return U.log('Phone offline');
  }), false);
};

document.addEventListener("deviceready", P.boot, false);
